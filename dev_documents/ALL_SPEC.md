MLIP Structure Generator 仕様解説
1. プロジェクト概要と目的
1.1 核心的な目的
本ツールの主目的は、MACEやSevenNetといった最新の機械学習ポテンシャルモデル（MLIP）をトレーニングするための、物理的に妥当かつ多様性に富んだ学習データを生成することです。 単にランダムな構造を作るのではなく、実際の分子動力学（MD）シミュレーションやモンテカルロ（MC）法を用いることで、熱力学的にアクセス可能な位相空間（Phase Space）を探索し、学習に必要な「失敗しやすい配置（高エネルギー配置や遷移状態）」を効率的に収集する設計となっています。

1.2 対応する物理系
設定ファイルおよびファクトリクラスの記述から、以下の広範な物理系に対応しています。

Alloy (合金): 多元系合金、固溶体。

Ionic (イオン結晶): 酸化数に基づく電荷バランスを考慮した酸化物など。

Covalent (共有結合): グラファイトやダイヤモンドのような構造。

Interface (界面): 異種材料間の界面（ヘテロ構造）。

Adsorption (吸着): 表面（Slab）上の分子吸着。

Knowledge-based: 化学式（例: Fe3Pt）から対称性やデータベース(COD)のロジックを用いて構造を推定・生成。

2. パイプライン・アーキテクチャ
システムの中核は src/nnp_gen/pipeline/runner.py に記述された PipelineRunner クラスによって制御されています。処理は大きく以下の4段階のシーケンスで進行します。

Step 1: 初期構造生成 (Generation)
ユーザーの設定に基づき、シミュレーションの出発点となる原子配置（Seed Structures）を作成します。

再開機能: 既存の initial_structures.xyz があればそれを読み込み、なければ新規生成します。

保存: 生成された構造は即座にデータベース（Checkpoints DB）とディスクに保存され、後続プロセスとの分離（State Isolation）が図られています。

Step 2: 探索 (Exploration)
生成された初期構造に対し、分子動力学（MD）あるいはハイブリッドMD/MCを実行し、構造を「揺らし」て多様な配置を生み出します。

並列処理: Pythonの ProcessPoolExecutor を用いて、複数のシミュレーションを並列実行します。

プログレッシブ保存: 探索の途中経過は随時ファイルに追記され、クラッシュ時のデータ損失を防ぐ設計です。

Step 3: サンプリング (Sampling)
探索で得られた膨大なトラジェクトリ（軌跡）の中から、学習に有効な構造のみを抽出します。

手法: ランダムサンプリング、またはSOAP記述子を用いたFPS（Farthest Point Sampling）が実装されています。FPSは構造的な類似度が低い（＝多様性が高い）データを優先的に選ぶ手法です。

Step 4: データベース格納 (Storage)
最終的に選別されたデータセットは、ASE（Atomic Simulation Environment）ベースのデータベース（SQLite）にメタデータと共に格納されます。

3. 詳細機能と内部ロジック
各モジュールの技術的な詳細仕様を解説します。

3.1 構造生成ロジック (Generators)
src/nnp_gen/generators/ 以下に各物理系ごとの生成ロジックが実装されています。共通の親クラス BaseGenerator は、生成された構造に対して物理的な妥当性チェック（バリデーション）を強制します。

物理的制約 (Physics Constraints):

原子間距離チェック: overlap_check により、原子が不自然に近すぎる構造を排除します。

スーパーセル拡張: ensure_supercell_size 関数により、カットオフ半径（r_cut）よりも大きなセルサイズになるよう自動的にスーパーセルを作成します。これは周期的境界条件（PBC）下での自己相互作用を防ぐためです。

歪みとラトル: apply_volumetric_strain（体積歪み）や apply_rattle（原子位置の微小ノイズ）を適用し、データの頑健性を高めます。

3.2 探索エンジン (MD/MC Explorer)
src/nnp_gen/explorers/md_engine.py がこのツールの最も複雑かつ重要な部分です。

ハイブリッド MD/MC:

通常のMDシミュレーションの合間に、モンテカルロ（MC）ムーブを挿入可能です。

Swap Move: 異種原子の位置を入れ替える操作。合金の配置探索に有効です。

Vacancy Hop (Smart Rattle): 空孔（Vacancy）周辺の原子を動かすことで、拡散現象を模倣します。

自動アンサンブル切り替え (Auto Ensemble Switching):

detect_vacuum 関数（グリッドベースの空隙検知アルゴリズム）を使用し、系が「バルク」か「表面/スラブ」かを自動判定します。

バルクの場合: NPTアンサンブル（定圧定温）を選択し、セルの緩和を許可します。

表面の場合: NVTアンサンブル（定積定温）を選択し、真空層が勝手に縮んだり膨張したりするアーティファクトを防ぎます。

ZBLポテンシャルの統合:

原子同士が極端に接近した際の高エネルギー反発を正しく記述するため、MACEなどのMLIPと古典的なZBLポテンシャルを混合（Mixing）する機能を有しています。これにより、高温シミュレーションでの「クーロン爆発」や物理的にあり得ない融合を防ぎます。

3.3 安全機構とエラーハンドリング
探索プロセスは非常に堅牢に設計されています。

クーロン爆発の防止: イオン系において、電荷バランスが崩れるようなスワップ（例: Na+ と Cl- の交換）を禁止する Charge Safety 機能があります。

重複排除とクラッシュダンプ: シミュレーション中に原子が重なりすぎた場合（PhysicsViolationError）、その構造を即座に破棄し、デバッグ用にファイル出力する機能が run_single_md_process 内に組み込まれています。

プロセス分離: ProcessPoolExecutor を使用していますが、CUDAを使用する場合（GPU利用時）は、マルチプロセスによる競合を防ぐために強制的に max_workers=1 に制限するか、あるいは慎重なリソース管理を行うロジックが含まれています。

4. 設定と拡張性 (Configuration)
設定管理には Hydra が採用されており、柔軟なオーバーライドが可能です。

4.1 主な設定項目
system: 生成する物理系の定義（元素、組成比、空間群、初期構造数など）。

exploration: 温度、圧力、タイムステップ、使用するMLモデル（MACE, SevenNet, EMT）、MCの設定。

特筆すべきは temperature_mode: gradient で、徐々に温度を上げる/下げる設定が可能です。

sampling: 生成後のデータ選別手法（Random vs FPS）。

4.2 ユーザーインターフェース
CLI (Command Line Interface): main.py を通じてバッチ処理を実行。

Web UI: main_gui.py により、ブラウザ上でパラメータ設定や構造の可視化（Visualization）が可能です。

5. 技術的特異点と優位性
このプロジェクトが単なるスクリプト集と異なる点は、以下の「エンジニアリング品質」にあります。

Late Binding Calculator: md_engine.py では、計算機（Calculator）のインスタンス化を親プロセスではなく、各ワーカプロセス内で行っています（_get_calculator）。これにより、巨大なMLモデル（PyTorchモデル等）をpickle化してプロセス間で送受信する際の非効率やエラーを回避しています。また、プロセス内キャッシュを用いてモデルの再ロード時間を短縮しています。

物理ベースのバリデーション: physics.py における detect_vacuum は、単純なセルサイズチェックではなく、セル内にグリッド点を配置し、原子からの距離を計測することで「真の空隙（真空層）」を検出する高度なロジックを実装しています。

Active Learningへの指向: 高温（例: 1500K〜2000K）でのシミュレーションをデフォルトで想定しており、ポテンシャルエネルギー曲面（PES）の未知領域を探索することを強く意識した設計です。

6. まとめ
mlip_struc_generator は、**「物理的整合性の担保」と「探索の多様性」**を両立させた、MLIP開発者向けの高度なデータセット生成フレームワークです。

入力: ユーザー定義の構成（合金比率、化学式）または外部ファイル（CIF/XYZ）。

処理: 物理ルールに基づいた初期生成 → 自動アンサンブル選択機能を備えたハイブリッドMD/MC探索。

出力: 物理的に破綻していない、かつ学習効果の高い原子構造データベース。

特に、MACEのような最新のMLIPモデルと連携しつつ、ZBLポテンシャルによる短距離補正や、並列処理時のメモリ/GPU管理まで考慮されている点が、実用レベルのツールであることを示しています。